["\n9.3. A First Look at Classes\u00b6\nClasses introduce a little bit of new syntax, three new object types, and some\nnew semantics.\n\n9.3.1. Class Definition Syntax\u00b6\nThe simplest form of class definition looks like this:\nclass ClassName:\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n\n\nClass definitions, like function definitions (def statements) must be\nexecuted before they have any effect.  (You could conceivably place a class\ndefinition in a branch of an if statement, or inside a function.)\nIn practice, the statements inside a class definition will usually be function\ndefinitions, but other statements are allowed, and sometimes useful \u2014 we\u2019ll\ncome back to this later.  The function definitions inside a class normally have\na peculiar form of argument list, dictated by the calling conventions for\nmethods \u2014 again, this is explained later.\nWhen a class definition is entered, a new namespace is created, and used as the\nlocal scope \u2014 thus, all assignments to local variables go into this new\nnamespace.  In particular, function definitions bind the name of the new\nfunction here.\nWhen a class definition is left normally (via the end), a class object is\ncreated.  This is basically a wrapper around the contents of the namespace\ncreated by the class definition; we\u2019ll learn more about class objects in the\nnext section.  The original local scope (the one in effect just before the class\ndefinition was entered) is reinstated, and the class object is bound here to the\nclass name given in the class definition header (ClassName in the\nexample).\n\n\n9.3.2. Class Objects\u00b6\nClass objects support two kinds of operations: attribute references and\ninstantiation.\nAttribute references use the standard syntax used for all attribute references\nin Python: obj.name.  Valid attribute names are all the names that were in\nthe class\u2019s namespace when the class object was created.  So, if the class\ndefinition looked like this:\nclass MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n\n\nthen MyClass.i and MyClass.f are valid attribute references, returning\nan integer and a function object, respectively. Class attributes can also be\nassigned to, so you can change the value of MyClass.i by assignment.\n__doc__ is also a valid attribute, returning the docstring belonging to\nthe class: \"A simple example class\".\nClass instantiation uses function notation.  Just pretend that the class\nobject is a parameterless function that returns a new instance of the class.\nFor example (assuming the above class):\nx = MyClass()\n\n\ncreates a new instance of the class and assigns this object to the local\nvariable x.\nThe instantiation operation (\u201ccalling\u201d a class object) creates an empty object.\nMany classes like to create objects with instances customized to a specific\ninitial state. Therefore a class may define a special method named\n__init__(), like this:\ndef __init__(self):\n    self.data = []\n\n\nWhen a class defines an __init__() method, class instantiation\nautomatically invokes __init__() for the newly created class instance.  So\nin this example, a new, initialized instance can be obtained by:\nx = MyClass()\n\n\nOf course, the __init__() method may have arguments for greater\nflexibility.  In that case, arguments given to the class instantiation operator\nare passed on to __init__().  For example,\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n\n\n\n\n9.3.3. Instance Objects\u00b6\nNow what can we do with instance objects?  The only operations understood by\ninstance objects are attribute references.  There are two kinds of valid\nattribute names: data attributes and methods.\ndata attributes correspond to \u201cinstance variables\u201d in Smalltalk, and to \u201cdata\nmembers\u201d in C++.  Data attributes need not be declared; like local variables,\nthey spring into existence when they are first assigned to.  For example, if\nx is the instance of MyClass created above, the following piece of\ncode will print the value 16, without leaving a trace:\nx.counter = 1\nwhile x.counter < 10:\n    x.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\n\n\nThe other kind of instance attribute reference is a method. A method is a\nfunction that \u201cbelongs to\u201d an object.  (In Python, the term method is not unique\nto class instances: other object types can have methods as well.  For example,\nlist objects have methods called append, insert, remove, sort, and so on.\nHowever, in the following discussion, we\u2019ll use the term method exclusively to\nmean methods of class instance objects, unless explicitly stated otherwise.)\nValid method names of an instance object depend on its class.  By definition,\nall attributes of a class that are function  objects define corresponding\nmethods of its instances.  So in our example, x.f is a valid method\nreference, since MyClass.f is a function, but x.i is not, since\nMyClass.i is not.  But x.f is not the same thing as MyClass.f \u2014 it\nis a method object, not a function object.\n\n\n9.3.4. Method Objects\u00b6\nUsually, a method is called right after it is bound:\nx.f()\n\n\nIn the MyClass example, this will return the string 'hello world'.\nHowever, it is not necessary to call a method right away: x.f is a method\nobject, and can be stored away and called at a later time.  For example:\nxf = x.f\nwhile True:\n    print(xf())\n\n\nwill continue to print hello world until the end of time.\nWhat exactly happens when a method is called?  You may have noticed that\nx.f() was called without an argument above, even though the function\ndefinition for f() specified an argument.  What happened to the argument?\nSurely Python raises an exception when a function that requires an argument is\ncalled without any \u2014 even if the argument isn\u2019t actually used\u2026\nActually, you may have guessed the answer: the special thing about methods is\nthat the instance object is passed as the first argument of the function.  In our\nexample, the call x.f() is exactly equivalent to MyClass.f(x).  In\ngeneral, calling a method with a list of n arguments is equivalent to calling\nthe corresponding function with an argument list that is created by inserting\nthe method\u2019s instance object before the first argument.\nIf you still don\u2019t understand how methods work, a look at the implementation can\nperhaps clarify matters.  When a non-data attribute of an instance is\nreferenced, the instance\u2019s class is searched.  If the name denotes a valid class\nattribute that is a function object, a method object is created by packing\n(pointers to) the instance object and the function object just found together in\nan abstract object: this is the method object.  When the method object is called\nwith an argument list, a new argument list is constructed from the instance\nobject and the argument list, and the function object is called with this new\nargument list.\n\n\n9.3.5. Class and Instance Variables\u00b6\nGenerally speaking, instance variables are for data unique to each instance\nand class variables are for attributes and methods shared by all instances\nof the class:\nclass Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\n\n\nAs discussed in A Word About Names and Objects, shared data can have possibly surprising\neffects with involving mutable objects such as lists and dictionaries.\nFor example, the tricks list in the following code should not be used as a\nclass variable because just a single list would be shared by all Dog\ninstances:\nclass Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n\n\nCorrect design of the class should use an instance variable instead:\nclass Dog:\n\n    def __init__(self, name):\n        self.name = name\n        self.tricks = []    # creates a new empty list for each dog\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n\n\n\n"]